<!DOCTYPE html>
<html>
    <head>
        <link href="/theme/css/normalize.css" rel="stylesheet">
        <link href="/theme/css/skeleton.css" rel="stylesheet">
        <link href="/theme/css/statocles-default.css" rel="stylesheet">
        <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">
        <title>Neil H. Watson</title>
        <meta content="Statocles 0.059" name="generator">
        <link href="/blog/index.atom" rel="alternate" type="application/atom+xml">
        <link href="/blog/index.rss" rel="alternate" type="application/rss+xml">
        
    </head>
    <body>
        <header>
            <nav class="navbar">
                <div class="container">
                    <a class="brand" href="/">Neil H. Watson</a>
                    <ul>
                        <li>
                            <a href="/">Blog</a>
                        </li>
                    </ul>
                    
                </div>
            </nav>
            
        </header>
        <div class="main container">
            
<div class="row">

    <div class="nine columns">
        <main>


            <article>
                <header>
                    <h1><a href="/blog/2011/03/08/enterprise-sysadmin/">Enterprise system administration using configuration management</a></h1>

                    <p class="tags">Tags:
                        <a href="/blog/tag/configuration-management/" rel="tag">configuration management</a>
                        <a href="/blog/tag/sysadmin/" rel="tag">sysadmin</a>
                        <a href="/blog/tag/cfengine/" rel="tag">cfengine</a>
                    </p>

                    <aside>
                        <p><time datetime="2011-03-08">
                            Posted on 2011-03-08
                        </time>
                        </p>
                    </aside>

                </header>

                <p>To maintain the large quantity of servers typically found in enterprise organizations, systems administration must move beyond manual and custom scripts toward a centralized configuration management service. This move can save an organization considerable time and money.</p>

<p>Contents</p>

<pre><code>Introduction
Stages of configuration management
    Manual stage
    Custom automation stage
    Dedicated service stage

Practical Examples
    Security
    Automated builds
    Host replacement
    Self healing

Savings
Perception of control
</code></pre>

<p>Introduction</p>

<p>When talking about system administration in this paper I am referring to the act of maintaining UNIX hosts and their services. System administration is more than this but for this paper I will discuss only a subset of system administration skills which I call configuration management. Configuration management is the act of creating new hosts and maintaining existing ones and their services according to the specifications of an organization’s policies.
Stages of configuration management</p>

<p>As an organization adds more and more hosts, both physical and virtual, its system administrators must spend more and more time ensuring that all hosts comply with policy. This results in an explosive demand in manpower. Organizations can often find themselves constantly falling behind, never able to finish projects on time or neglecting less visible infrastructure in order to deliver other highly visible projects.</p>

<p>In order to prevent this situation the organization must grow its methods of configuration management. The growth of configuration management usually has three distinct phases: manual, custom automation, and dedicated service. Few organizations grow beyond the manual stage. Fewer still beyond custom automation.
Manual stage</p>

<p>Management the manual way (see figure 1) involves copying files and issuing manual commands repeatedly to every host. With this method a simple three minute change applied to sixty hosts becomes a two hour job. Worse still, such changes are static. There is no way to know if changes are still in place without a manual audit.</p>

<p>Figure 1: Manual configuration management manual-admin.png</p>

<p>Custom automation stage</p>

<p>Some administrators develop a kit of custom scripts (see figure 2) and files that are deployed from host to host by a further set of custom scripts and services. This method is effective by allowing the administrator to automate a change across all hosts but does not scale well. More and more scripts must be created and maintained as the number of hosts and services grow. Trying to maintain an ever growing collection of dissimilar custom scripts can become a project of its own. Further, new members of the system administrator team will have to spend time learning this entirely custom environment.
Figure 2: Custom configuration management scripted-admin.png</p>

<p>Dedicated service stage</p>

<p>A dedicated configuration management service (see figure 3) offers the time savings of automated custom scripts but in a more maintainable way. A Dedicated service has built in methods for handling many configuration changes that eliminate the need for custom scripts. Also, since this service is not entirely custom it is possible to find new team members with previous experience.
Figure 3: Dedicated configuration management config-admin.png</p>

<p>Dedicated configuration management allows system administrators to control servers from a central location. Administrators are able to make a single manual change and have that change automatically deployed to all desired hosts across the network. The configuration management service continuously ensures that these changes are applied. This can save an organization time and money. All changes in a configuration management system are version controlled. This means that all change history is recorded for auditing and disaster recovery.
Practical Examples</p>

<p>The following are practical examples of how configuration management can save an organization countless resources.
Security</p>

<p>A tedious and constantly changing security policy must be maintained across some or all hosts. Many aspects of a security policy define how a service or host should be configured. A typical security policy may touch upon PAM files, log file permissions, log history retention, home directory permissions and SSH configuration to name a few. A configuration management service can be used to maintain all of these examples and more. Using this service ensures that hosts meet the current policy requirements. New hosts will have the policy automatically applied. Policy changes need only be defined once then applied automatically to all current and future hosts.</p>

<p>All configurations are stored in the configuration management service’s master files location. The master files are version controlled. With version control one can easily determine every line that has been changed, when that change was checked in and by whom.
Automated builds</p>

<p>Jumpstart or kickstart services can only accomplish so much. Final configurations are typically done by hand or by a collection of custom scripts. A configuration management service can apply all additional custom policy changes to the host automatically.
Host replacement</p>

<p>Host replacement either for end of life hosts or disaster recovery can be more automated by using the configuration management service. All configurations of the original host are pointed toward the new host where they will be applied automatically.
Self healing</p>

<p>Some organizations run services to ensure that services and processes are running, or sometimes not running, on selected hosts. These services are often given the name network management or network monitoring. Configuration management cannot replace the essential service of network monitoring but it can augment it.</p>

<p>Configuration management services can ensure that configuration files are correct and whether or not services are running. Network monitoring services typically send notification when services fail. Configuration management services can actually make corrections preventing the need for notification.</p>

<p>Finally it is also possible for a network monitoring service to automatically activate a configuration management service when it detects a failure. This corrective action may repair the failure, again without the need for notification.
Savings</p>

<p>With manual tasks automated staff will now have more time to focus on important projects. Large tasks like security audits or patch updates can now be automated across all hosts. (See table 1)</p>

<p>Now consider service outages. Suppose that the configuration management”s self healing nature prevents just two outages per year. How many employees had to work, or could not work during those outages? Typically even a small outage can cost an organization a considerable amount of lost time.</p>

<p>Task  Annual time saved in hours
   Per host    100 hosts   1000 hosts
Security audit    1  100   1000
Patch deployment  0.5   50    500
New security change  0.5   50    500
Total savings  2  200   2000</p>

<p>Perception of control</p>

<p>Some organizations are not comfortable with the kind of automation that configuration management offers. They argue that such automation reduces their control. It is safer, they argue, to have a system administrator oversee things personally.</p>

<p>Consider that if administrators have to manually confirm that all host configurations are current then they are already out of control. If a host’s configuration has diverged from policy it is going to take some time for an administrator to manually discover the problem. It is more likely that a customer will discover and report the problem first. Where is the control?</p>

<p>Now consider system administrators using a configuration management service. The administrators can focus on developing their policy centrally while allowing the configuration management service to ensure that each host conforms the policy. Using this method both computer and the human administrator can focus on what they are best at. The administrator can creatively develop complicated host polices and the computers can continuously and autonomously ensure compliance to them.</p>



            </article>
            <article>
                <header>
                    <h1><a href="/blog/2011/03/08/cfengine-tutorial/">CFEngine tutorial</a></h1>

                    <p class="tags">Tags:
                        <a href="/blog/tag/cfengine/" rel="tag">cfengine</a>
                        <a href="/blog/tag/configuration-management/" rel="tag">configuration management</a>
                    </p>

                    <aside>
                        <p><time datetime="2011-03-08">
                            Posted on 2011-03-08
                        </time>
                        </p>
                    </aside>

                </header>

                <ol>
<li><p><a href="/blog/2011/03/08/cfengine-tutorial/#overview">Overview</a></p></li>
<li><p><a href="/blog/2011/03/08/cfengine-tutorial/#basic">Basic example</a></p></li>
<li><p><a href="/blog/2011/03/08/cfengine-tutorial/#others">Other examples</a></p></li>
</ol>

<h2><a name="overview"></a>Overview</h2>

<p>Cfengine is a configuration management tool that allows a system administrator
to configure multiple hosts continuously. Cfengine runs as a client/server
application. The server provides new configurations, or policy, while the
client works to ensure that a client host conforms to them.</p>

<p>The policy is written the descriptive language of Cfengine. This language
describes what the running state of a host or hosts should be. The agent, over
one or more iterations, makes the client conform to this policy in a convergent
manner.</p>

<p>Figure: Cfengine Cycle cfcycle.png</p>

<p>As seen in the figure Cfengine agents (cf-agent) contact the policy server
(cf-serverd) for new or changed policies or files. This is a “pull” method in
which the client contacts the server instead of a “push” method where the
server contacts the client. Using the “pull” method allows the client to
operate autonomously in the absence of the server. This allows for greater
reliability.</p>

<p>The security implications often associated with pull clients can if desired by
alleviated by the use of policy mirrors (see figure).</p>

<p>Figure: Cfengine Mirror mirror.png</p>

<p>Cfengine 3 consists of a number of components. As this is an introductory
tutorial some components will not be covered here.</p>

<ol>
<li>cf-agent Active agent</li>
<li>cf-execd Scheduler</li>
<li>cf-graph Graph data extractor</li>
<li>cf-know Knowledge modelling agent</li>
<li>cf-monitord Passive monitoring agent</li>
<li>cf-promises Promise validator</li>
<li>cf-runagent Remote run agent</li>
<li>cf-serverd Server that acts mostly like a file server for cf-agent.</li>
<li>cf-report Self-knowledge extractor</li>
</ol>

<p>The daemon formally called cfenvd in previous versions of Cfengine is now
called cf-monitord.</p>

<p>Cfengine files are normally located in /var/cfengine. Cfengine will create some
directories automatically in this location. The two important ones that must be
created by hand are /var/cfengine/bin and /var/cfengine/inputs. The bin
directory contains the binary components listed earlier. This location allows
for Cfengine to be more self contained and fault tolerant. For example, the
traditional location of /usr/local/bin is not always a local file systems
and therefore less reliable.</p>

<p>The inputs directory contains all of the configuration files that Cfengine will
use to maintain itself and the client hosts. The majority of work with Cfengine
will involve files located here. The mandatory files are failsafe.cf, update.cf
and promises.cf. Other files are user defined and will be discussed later.</p>

<h2><a name="basic"></a>Basic example</h2>

<p>Here I’ll present a basic example of Cfengine. Functionally it will do little
more than ensuring that Cfengine is running. What is learned from this example
will be applicable to more practical uses.</p>

<p>Cfengine can run on virtually any UNIX host. It can also run on Windows with
the help of the Cygwin environment. One can either choose to install Cfengine
from a distributions application repository (e.g. Debian or Freshports) or
download the source from Cfengine.org and compile it. The source code contains
all of the necessary instructions to compile and install Cfengine. Note that
there are some dependencies that must be met before Cfengine can be built. The
source code contains information on these also. An automated distribution
install will take care of these automatically.</p>

<h3>Directories and files</h3>

<ol>
<li>/var/cfengine/bin Cfengine binaries.</li>
<li>/var/cfengine/inputs Main configuration files.</li>
<li>/var/cfengine/ppkeys Storage for authentication keys.</li>
<li>/var/cf-masterfiles The master files, on the server, that agents will request from the server.</li>
<li><p>/var/cf-failsafe A backup of important Cfengine files to allow for automatic recovery.</p></li>
<li><p>promises.cf This is the main configuration file. The agent will automatically start with this file.</p></li>
<li>update.cf This is a simplified file whose purpose is to ensure the agent is configured properly so that it can do its job.</li>
<li>failsafe.cf This file is run by the agent if other files are missing or contain errors. This gives the agent the ability to recover itself from failure.</li>
<li>cf-server.cf This file configures the Cfengine server. It can be named anything but choosing this name is logical.</li>
<li>cf-execd.cf This file will configure the Cfengine executor. Like cfserver.cf this file could be named something else.</li>
<li>cfbackup.cf This makes a local backup of Cfengine to ensure the agent can recover from serious data loss.</li>
<li>crontabs.cf This manages host crontables.</li>
<li>library.cf This contains a collection of reusable code similar to a subroutine library.</li>
</ol>

<h3>Key authentication</h3>

<p>Cfengine agents authenticate with a server via key exchange. The cf-key binary
will create a public and private key pair. This is done for every server and
client. For two hosts to authenticate each must have a copy of the other’s
public key file. This exchange is normally done manually but Cfengine may be
configured to do this one time only. Please refer to the reference manual for
more information.</p>

<p>The syntax of Cfengine files is relatively simple and somewhat Perl like.
However, Cfengine tends to be more sensitive to white space.</p>

<ol>
<li>Sections are contained withing brackets.</li>
<li>Commas separate parts of the same action.</li>
<li>Actions are ended with a semicolon.</li>
<li>Body part lines end with semicolons.</li>
<li>Variables are identified by $ and usually contained in brackets to separate them from surrounding text.</li>
<li>Most user defined information is contained within double quotations.</li>
<li>Comments begin with # or can be included in the promise so that Cfengine will print them during a run (comment =&gt; &quot;My comment&quot;).</li>
</ol>

<p>If you follow the examples contained in this paper you’ll not have to worry
much about syntax.</p>

<p>There are three Cfengine commands you&#39;ll need to use for these examples. The
server is started by cf-serverd. After starting it will fork to the background.
The command cf-promises will validate a Cfengine policy. It is a good way to
check for syntax errors. Finally cf-agent is the agent that will do the work.
Using the -v and -n options will allow you to test and debug your policy.</p>

<p>The promises.cf file is the first file that Cfengine reads.</p>

<pre><code>1  #######################
2  # promises.cf
3  #######################
4  
5  body common control {
6      bundlesequence =&gt; {
7          &quot;update&quot;,
8          &quot;executor&quot;,
9          &quot;server&quot;,
10         &quot;crontabs&quot;,
11         &quot;cfbackup&quot; # should be last
12      };
13  
14      inputs =&gt; {
15          &quot;update.cf&quot;,
16          &quot;library.cf&quot;,
17          &quot;cf-serverd.cf&quot;,
18          &quot;cf-execd.cf&quot;,
19          &quot;crontabs.cf&quot;,
20          &quot;cfbackup.cf&quot;
21      };
22  }
23  
24  bundle common g{
25      vars: 
26          &quot;masterfiles&quot; string =&gt; &quot;/var/cf-masterfiles&quot;;
27 &quot;inputs&quot; string =&gt; &quot;${masterfiles}/config/branches/cf3/inputs&quot;;
28              &quot;workdir&quot; string =&gt; &quot;/var/cfengine&quot;;
29          # for HA add more policy hosts
30          &quot;phost&quot; string =&gt; &quot;192.168.0.1&quot;;
31  }
32  
33  body agent control {
34      # Do not rely on DNS
35      skipidentify =&gt; &quot;true&quot;;
36  }
</code></pre>

<p>Lines 5-12 define the bundlesequence. Previously Cfengine determined actions
via the actionsequence. In Cfengine 3 the sequence of actions is defined by
Cfengine and is based on the previous experience of developers and users.
Cfengine 3 now offers something called a bundle. A bundle is a list of actions
(e.g. files, shell commands, processes) grouped for a single purpose. These
bundles will be executed in the order defined by the bundle sequence.</p>

<ol>
<li>update Update inputs if the policy server has changes to distribute.</li>
<li>executor: Configure cf-execd.</li>
<li>server: Configure cf-serverd.</li>
<li>crontabes: Configure a client host’s crontables.</li>
<li>cfbackup: Backup Cfengine’s configuration files for automated recovery.</li>
</ol>

<p>Lines 14-21 import other configuration files. A Cfengine policy can become very
large. Separating the policy into distinct files makes management easier. In
this case we separate mostly into bundles with the exception of library.cf
which hosts reusable code.</p>

<p>Lines 24-31 define some global variables. We will be able to refer to these
variable throughout our policy (e.g. ${g.masterfiles}).</p>

<p>Lines 33-35 instruct Cfengine to not use DNS to attempt to authenticate clients
and servers. This is entirely optional and depends on how reliable and
trustworthy your DNS service is.</p>

<p>The sole purpose of update.cf is to ensure that Cfengine has the latest policy
files. Once you have this file working do not change it unless absolutely
necessary.</p>

<pre><code>1  #######################
2  # update.cf 
3  #######################
4  
5  bundle agent update {
6  
7      vars: 
8      
9    &quot;masterfiles&quot; string =&gt; &quot;/var/cf-masterfiles&quot;;
10    &quot;inputs&quot; string =&gt; &quot;${masterfiles}/config/branches/cf3/inputs&quot;;
11  # for HA add more policy hosts
12          &quot;phost&quot; string =&gt; &quot;192.168.0.1&quot;;
13  
14      files:
15  
16      # Fix directories
17          &quot;/var/cfengine/.&quot;
18              create =&gt; &quot;true&quot;,
19              perms =&gt; usystem(&quot;0700&quot;);
20  
21          &quot;/var/cfengine/bin/.&quot;
22              create =&gt; &quot;true&quot;,
23              perms =&gt; usystem(&quot;0700&quot;);
24  
25          &quot;/var/cfengine/ppkeys/.&quot;
26              perms =&gt; usystem(&quot;0700&quot;);
27  
28      # Copy inputs
29          &quot;/var/cfengine/inputs&quot;
30              perms =&gt; usystem(&quot;0600&quot;),
31              copy_from =&gt; umycopy(&quot;${inputs}&quot;),
32              depth_search =&gt; urecurse(&quot;inf&quot;);
33  
34      # Copy binaries
35          &quot;/var/cfengine/bin/cf-failsafe.sh&quot;
36              perms =&gt; usystem(&quot;0700&quot;),
37              copy_from =&gt; 
38  umycopy(&quot;$(masterfiles)/config/branches/cf3/bin/cf-failsafe.sh&quot;);
39   
40          debian_5.64_bit::
41              &quot;/var/cfengine/bin&quot;
42              perms =&gt; usystem(&quot;0700&quot;),
43              copy_from =&gt; 
44  umycopy(&quot;$(masterfiles)/config/branches/cf3/bin/debian-5-64&quot;),
45              depth_search =&gt; urecurse(&quot;1&quot;);
46  }
47  
48  body depth_search urecurse(d) {
49      depth =&gt; &quot;${d}&quot;;
50      exclude_dirs =&gt; { &quot;\.svn&quot; };
51  }
52  
53  body perms usystem(p) {
54      mode =&gt; &quot;${p}&quot;;
55      owners =&gt; { &quot;root&quot; };
56      groups =&gt; { &quot;root&quot; };
57  }
58  
59  body copy_from umycopy(from) {
60      source =&gt; &quot;${from}&quot;;
61      servers =&gt; { &quot;${phost}&quot; };
62      compare =&gt; &quot;digest&quot;;
63      verify =&gt; &quot;true&quot;;
64  #    purge =&gt; &quot;true&quot;;
65  }
</code></pre>

<p>The following will jump around a little in an attempt to give the reader the
entire picture.</p>

<p>Line 5 begins the bundle, for the agent, called “update”.</p>

<p>Lines 7-12 define some local variables. Recall that we define similar variables
globally in promises.cf. The purpose of update.cf is to keep the configuration
functional and up to date even if other files are missing or damaged. Thus this
file is designed to be self contained. It is also run first in the bundle
sequence so that policies can be updated or repaired before they are in turn
run.</p>

<p>Line 14 begins the files action. Files actions can involve creation, setting
permissions, copying, deleting or even editing.</p>

<p>Lines 17-19 ensure that the permissions of /var/cfengine are set to mode 0700.
Line 18 will actually create the directory if it is missing. Line 19 calls a
“body part”. Body parts a somewhat like functions or subroutines. In this
instance the string 0700 it past to the part usystem which is defined on lines
54 to 58.</p>

<p>Line 53 identifies the body part as being used for permissions (perms), names
it (usystem) and defines what variable will receive the passed data (p).</p>

<p>Line 54 sets the mode using the variable “p” which was passed from above.</p>

<p>Lines 55-56 set the user and group ownerships.</p>

<p>Line 57 ends the body part.</p>

<p>Lines 21-26 define the directories /var/cfengine/bin and /var/cfengine/ppkeys
in the same way as /var/cfengine was defined.</p>

<p>Lines 29-32 define the contents of /var/cfengine/inputs.</p>

<p>Line 30 sets the permissions using the “usystem” body part. Note that Cfengine
will automatically add the executable bit to directories.</p>

<p>Line 31 sets the copy source and calls the body part “umycopy” and passes the
variable “inputs” to it. The variable inputs was defined on line 10. It tells
Cfengine the location of the source files that are to be copied to
/var/cfengine inputs.</p>

<p>Lines 59-65 define the copy_from body part named “umycopy”.</p>

<p>Line 59 identifies the body part, its type (copy_from), its name (umycopy) and
what variable to store its passed data in (from).</p>

<p>Line 60 defines the copy source with the contents of the “from” variable.</p>

<p>Line 61 defines the source server from the “phost” variable.</p>

<p>Line 62 instructs Cfengine determine if a file needs updating from the source
by comparing the MD5 hash of each.</p>

<p>Line 63 instructs Cfengine to verify the copied file with the source before
committing the copy.</p>

<p>Line 64 instructs the agent to delete any files at the destination that are not
at the source. In effect this removes old files.</p>

<p>Line 32 sets the depth of the recursive copy and calls the body part “urecurse”
and passes the string “inf” to it.</p>

<p>Lines 48-51 define the “urecurse” body part.</p>

<p>Line 48 identifies the body part, its type (depth_search), its name (urecurse)
and the variable that will take the data passed to it (d).</p>

<p>Line 49 define the depth of the directories to compare. From line 32 this is
set to infinite. It could be set to something else which allows for control
similar to the UNIX “find” command.</p>

<p>Line 50 instructs the search to exclude any paths containing the string “.svn”.
That string is a regular expression so the period must be escaped for it to be
taken literally. This line is used because our master files, the source of this
copy, are found in a Subversion working copy. The .svn directories found in
Subversion working copies do not need to be copied.</p>

<p>Line 51 ends the “urecurse” body part.</p>

<p>Line 35 defines another copy but this time only a single file: cf-failsafe.sh.</p>

<p>Line 40 defines a class of host. Until now we have not defined any classes.
Thus any agent would run the actions defined. In this case we define a class of
“debian_5.64_bit” to instruct the agent to run the following actions only on
Debian 5 hosts that are 64 bit. When the agent runs it will determine many hard
classes including the UNIX distribution automatically.</p>

<p>Line 45 defines the depth of the search body part as 1 in this case because we
only wish to copy that single file.</p>

<p>Cfengine defaults to failsafe.cf if other regular files such as promises.cf
have errors. There are many ways that one might be creative with this file.</p>

<pre><code>1  #######################
2  # failsafe.cf 
3  #######################
4  
5  body common control { 
6      bundlesequence =&gt; { &quot;update&quot; }; 
7      inputs =&gt; { &quot;update.cf&quot; }; 
8  }
</code></pre>

<p>This file simple tells Cfengine to run the update.cf file.</p>

<p>When we discussed update.cf we showed several body parts that acted similarly
to fuctions or subroutines. Since update.cf is meant to be self contained
specialized body parts were included in that file. Normally it is efficient to
reuse the same body parts as much as possible throughout the the Cfengine
policy. This library.cf file contains a collection of resuable parts. The
makers of Cfengine now offer a large library of body parts ready for use. This
is called the Community Open Promise Body Library. It can be a realy time
saver.</p>

<pre><code>1  # Library of commond code
2  
3  body depth_search recurse(d) {
4      depth =&gt; &quot;${d}&quot;;
5  # exclude .svn revision control files
6      exclude_dirs =&gt; { &quot;\.svn&quot; };
7  }
8  
9  body perms system(p,u,g) {
10      mode =&gt; &quot;${p}&quot;;
11      owners =&gt; { &quot;${u}&quot; };
12      groups =&gt; { &quot;${g}&quot; };
13  }
14  
15  body copy_from mycopy(from,server) {
16      source =&gt; &quot;${from}&quot;;
17      servers =&gt; { &quot;${server}&quot; };
18      compare =&gt; &quot;digest&quot;;
19  }
</code></pre>

<p>Lines 3-7 define the recursive search body part. It is defined similarly to the
part in update.cf. Only the name is different. Note the comment in line 5.</p>

<p>Lines 9-13 define the body part that sets file permissions. Unlike the part in
update.cf this part takes three arguments: the mode, owner and group.</p>

<p>Lines 15-19 define the part that sources where files are copied from. Here we
pass the source path and the server. Note that on line 17 the server is defined
more like an array. This allows for the use of redundant servers. Line 18
defines that copies are compared using MD5 hashes.</p>

<p>The file cf-serverd configures the cf-serverd process.</p>

<pre><code>1  body server control {
2  # Do not use DNS
3      skipverify =&gt; { &quot;192.168.0.*&quot; };
4      allowconnects =&gt; { &quot;192.168.0.0/24&quot; };
5      allowallconnects =&gt; { &quot;192.168.0.0/24&quot; };
6      maxconnections =&gt; &quot;5&quot;;
7      logallconnections =&gt; &quot;true&quot;;
8      trustkeysfrom =&gt; { &quot;192.168.0.1&quot; };
9      bindtointerface =&gt; &quot;192.168.0.1&quot;;
10  
11      cfruncommand =&gt;
12              &quot;${g.workdir}/bin/cf-agent&quot;; 
13      allowusers =&gt; { &quot;root&quot; };
14  
15  }
16  
17  # ensure server is running.
18  bundle agent server {
19      processes:
20  
21          &quot;cf-serverd&quot;
22              restart_class =&gt; &quot;start_cfserverd&quot;;
23  
24      commands:
25  
26          start_cfserverd::
27              &quot;${g.workdir}/bin/cf-serverd&quot;;
28  }
29  
30  
31  bundle server access_rules {
32      access:
33          &quot;${g.masterfiles}&quot;
34              admit =&gt; { &quot;192\.168\.0\..*&quot; };
35  
36          # All policy hosts to &#39;push&#39;.
37          &quot;${g.workdir}/bin/cf-agent&quot;
38              admit =&gt; { &quot;${g.phost}&quot; };
39  }
40  
41  body runagent control {
42      hosts =&gt; {
43          &quot;192.168.0.1&quot;
44      };
45  }
</code></pre>

<p>Line 1 begins the control body for the server. Control is for defining required
settings.</p>

<p>Line 3 instructs the server to not attempt to verify the given IP range via DNS
lookups. If you have a very good DNS service you may not want to define this.</p>

<p>Line 4 defines a network from which the server will answer connections.</p>

<p>Line 5 defines the maximum connections the server will allow at one time.</p>

<p>Line 6 defines the maximum number of connections allowed from each node.</p>

<p>Line 7 tells the server to log all connections. This is very useful for
auditing and troubleshooting.</p>

<p>Line 8 tells the server to trust the key given to it from the stated IP
address. I only include this as it was needed for my lab setup. In production
it may be better to not state this and exchange all keys by hand.</p>

<p>Line 9 binds the server to a particular network interface. Unless your host has
multiple IP addresses you’ll not need this.</p>

<p>Lines 11-12 define the command that will be run when the run agent
(cf-runagent) contacts the server. The run agent allow push like actions. When
run on the policy host the run agent will contact the server process on each
client and instruct it to run the agent now to pull updates from the policy
server.</p>

<p>Line 13 allows the root user to be able to use the run agent.</p>

<p>Line 18 begins a bundle meant for the cf-agent.</p>

<p>Line 19 begins a processes action.</p>

<p>Line 21 tells the agent to search the processes table (e.g. ps -aux) for the
string “cf-serverd”.</p>

<p>Line 22 states that if the string from line 21 is not found then define the
class “start_cfserverd”.</p>

<p>Line 24 begins a commands action.</p>

<p>Line 26 calls the class “start_cfserverd” meaning that only agents with that
class may issue the next command.</p>

<p>Line 27 defines the command to be run should the agent belong to the class in
line 20.</p>

<p>Lines 19-27 simply stated, tell the agent to start the cf-serverd process if it
is not already running.</p>

<p>Line 31 begins a server bundle called access_rules. This allows for a more fine
grained control of what the agent may ask for from the server.</p>

<p>Line 31 begins an access action.</p>

<p>Line 33 lists a path on the server that the agent may access.</p>

<p>Line 34 defines the IP address, in a regular expression, that the agent must
have in order to access the path defined in line 27.</p>

<p>Line 37 lists a path to the agent binary.</p>

<p>Line 38 allows the policy host(s) to access this binary. This allows the run
agent on the policy server to invoke the agent on the clients for the pseudo
push.  cf-execd.cf</p>

<p>Recall that the executor, cf-execd, is a process that sits in the back ground
and starts cf-agent at defined intervals.</p>

<pre><code>1  #######################
2  # cf-execd.cf
3  #######################
4  
5  body executor control {
6      splaytime =&gt; &quot;1&quot;;
7      mailto =&gt; &quot;root@example.com&quot;;
8      smtpserver =&gt; &quot;192.168.0.1&quot;;
9      mailmaxlines =&gt; &quot;100&quot;;
10      schedule =&gt; { &quot;Min15_20&quot;, &quot;Min45_50&quot; };
11      executorfacility =&gt; &quot;LOG_DAEMON&quot;;
12  }
13  
14  bundle agent executor {
15  
16      processes:
17  
18          &quot;cf-execd&quot;
19              restart_class =&gt; &quot;start_cfexecd&quot;;
20  
21      commands:
22  
23          start_cfexecd::
24              &quot;${g.workdir}/bin/cf-execd&quot;;
25  
26  }
27  
28  # cf-execd is also added to the root 
29  # cron table in the cron inputs section.
</code></pre>

<p>Line 5 begins the control body for the executor.</p>

<p>Line 6 defines a random wait time (about 1 minute) that each executor will wait
when it”s schedule time is before it starts cf-agent. This it to prevent all
agents from connecting to the server at exactly the same time. If you have a
deployment of 1000 hosts this is a good thing.</p>

<p>Line 7 defines the address that any reports should be mailed to.</p>

<p>Line 8 defines the SMTP server that the mail from line 7 should be sent to.</p>

<p>Line 9 defines the maximum size of the email. DDOSing a mail server is never a
good thing.</p>

<p>Line 10 defines when the executor should start cf-agent. In this case twice per
hour during the alloted window. Note that exact timing is not a goal of
Cfengine. It is meant to work gradually.</p>

<p>Line 11 defines the syslog facility for the executor.</p>

<p>Line 14 begins a bundle that cf-agent will use to ensure that executor is
working properly. This is similar to the agent server bundle in cf-serverd.cf.</p>

<p>Lines 16-19 tell the agent to look for the process “cf-execd” and define a
restart class if it fails.</p>

<p>Lines 21-24 tell the agent to start the executor, cf-execd, if lines 16-19 did
not find an already running process.  crontabs.cf</p>

<p>This file configures cron tables for hosts.</p>

<pre><code>1  #######################
2  # crontabs.cf 
3  #######################
4  # IMPORTANT
5  # Please test crontabs before deploying them.
6  
7  bundle agent crontabs {
8   vars:
9      &quot;crontabs&quot; string =&gt; &quot;/var/spool/cron/crontabs&quot;;
10  
11   files:
12      &quot;${crontabs}/root&quot;
13          perms =&gt; system(&quot;0600&quot;,&quot;root&quot;,&quot;root&quot;),
14          copy_from =&gt; 
15 mycopy(&quot;${g.masterfiles}/config/branches/cf3/crontabs/ettin/root&quot;,&quot;${g.phost}&quot;);
16  }
</code></pre>

<p>Line 7 begins an agent bundle called crontabs.</p>

<p>Lines 8-9 define the variable “crontabs”.</p>

<p>Line 11 begins a files action.</p>

<p>Line 12 defines the target file.</p>

<p>Line 13 calls the “system” body part found in library.cf to set the file”s
ownership and permissions.</p>

<p>Lines 14-15 call the “mycopy” body part found in library.cf passing the source
file location and the source server. Notice the use of the global variables
that were defined in promises.cf.</p>

<p>The file cfbackup.cf file instructs Cfengine to make a failsafe backup of
itself. Thus even if Cfengine becomes damaged there is still hope of automatic
recovery.</p>

<pre><code>1  bundle agent cfbackup {
2  
3      vars:
4  
5          &quot;failsafe&quot; string =&gt; &quot;/var/cf-failsafe&quot;;
6  
7      files:
8  
9      &quot;${failsafe}/bin/cf-agent&quot;
10          perms =&gt; system(&quot;0700&quot;,&quot;root&quot;,&quot;root&quot;),
11 copy_from =&gt; mycopy(&quot;${g.workdir}/bin/cf-agent&quot;, &quot;localhost&quot;);
12  
13      &quot;${failsafe}/bin/cf-failsafe.sh&quot;
14          perms =&gt; system(&quot;0700&quot;,&quot;root&quot;,&quot;root&quot;),
15 copy_from =&gt; mycopy(&quot;${g.workdir}/bin/cf-failsafe.sh&quot;, &quot;localhost&quot;);
16  
17      &quot;${failsafe}/ppkeys&quot;
18          perms =&gt; system(&quot;0600&quot;,&quot;root&quot;,&quot;root&quot;),
19 copy_from =&gt; mycopy(&quot;${g.workdir}/ppkeys&quot;, &quot;localhost&quot;),
20          depth_search =&gt; recurse(&quot;inf&quot;);
21  
22      &quot;${failsafe}/inputs/failsafe.cf&quot;
23          perms =&gt; system(&quot;0600&quot;,&quot;root&quot;,&quot;root&quot;),
24 copy_from =&gt; mycopy(&quot;${g.workdir}/inputs/failsafe.cf&quot;, &quot;localhost&quot;);
25  
26      &quot;${failsafe}/inputs/update.cf&quot;
27          perms =&gt; system(&quot;0700&quot;,&quot;root&quot;,&quot;root&quot;),
28 copy_from =&gt; mycopy(&quot;${g.workdir}/inputs/update.cf&quot;, &quot;localhost&quot;);
29  
30  }
</code></pre>

<p>Line 1 begins a agent bundle called cfbackup.</p>

<p>Lines 3-6 define two variables.</p>

<p>Line 8 begins a files action.</p>

<p>Line 10-29 should look familiar by now. They instruct Cfengine to copy files.
There is one noticeable difference. The mycopy call passes the server
“localhost&amp;rdqduo and not the central policy server as we”ve seen in the past.
The purpose of this is to have the local client backup its own files locally.
Thus if the /var/cfengine directory is damaged it will be possible to recover
the files from an alternate local location without needing the remote server.</p>

<p>This shell script cf-failsafe.sh is not run by Cfengine but is called by the
host, via cron, in the event that cf-agent fails to run.</p>

<pre><code>1  #!/bin/sh
2  
3  # This file recovers cf from a very damaged state 
4 
5  
6  mkdir /var/cfengine
7  cp -pr /var/cf-failsafe/* /var/cfengine
8  /var/cfengine/bin/cf-agent &amp;&amp; /var/cfengine/bin/cf-agent
9
</code></pre>

<p>As you can see this is a simple backup script. Recall that in update.cf we
copied selective files from /var/cfengine to /var/cf-failsafe as a backup. This
script will be run if cf-agent cannot. In such cases the script will use the
contents of the /var/cf-failsafe directory to rebuild /var/cfengine (lines 6-7)
and then run the agent twice to finish the repairs (line 8).</p>

<p>Recall that in the cf-execd.cf file we instructed the agent to ensure that
cf-execd was running. Then in crontabs-cf we loaded a crontab file. One of the
entries in that crontab looks like this.</p>

<pre><code>15 4,16 * * * /var/cfengine/bin/cf-agent|| /var/cf-failsafe/bin/cf-failsafe.sh
</code></pre>

<p>At 0415 and 1614 each day cf-agent will be started. If that fails then the
failsafe script will be run instead. This is one of the many strategies one can
use to ensure that Cfengine will continue to run even the face of difficulty.</p>

<h2><a name="other"></a>Other examples</h2>

<p>Now that you’ve seen a basic example, lets look at some further ones to
illustrate how Cfengine might be used in production.</p>

<h3>Editing files</h3>

<p>In this example we’ll edit the NTP time server’s ntp.conf file. We’ll add our
own servers to the file allowing for us to define our NTP service across the
entire organization. This policy will append three “server” entries to the end
of the file “/etc/ntp.conf”.</p>

<pre><code>1  bundle agent ntp {
2  
3    vars:
4        &quot;ntp1&quot; string =&gt; &quot;tick.example.com&quot;;
5        &quot;ntp2&quot; string =&gt; &quot;tock.example.com&quot;;
6        &quot;ntp3&quot; string =&gt; &quot;ding.example.com&quot;;
7 
8    classes:
9        &quot;ntp_servers&quot; or =&gt; { &quot;${ntp1}&quot;, &quot;${ntp2}&quot;, &quot;${ntp3}&quot; };
10
11    files:
12        !ntp_servers::
13            &quot;/etc/ntp.conf&quot;
14                edit_line =&gt; 
15 AppendIfNoLine(&quot;server ${ntp1}&quot;, &quot;server ${ntp2}&quot;, &quot;server ${ntp3}&quot;);
16  }
17  
18  bundle edit_line AppendIfNoLine(a,b,c){
19    insert_lines:
20        &quot;${a}&quot; location =&gt; &quot;append&quot;;
21        &quot;${b}&quot; location =&gt; &quot;append&quot;;
22        &quot;${c}&quot; location =&gt; &quot;append&quot;;
23  }
24  
25  body location append {
26    before_after =&gt; &quot;after&quot;;
27  }
</code></pre>

<p>Line 1 begins an agent bundle called “ntp”.</p>

<p>Lines 3-6 define 3 variables each containing the FQDN of our NTP servers.</p>

<p>Lines 8-9 use our variables to define a class “ntp_servers” and makes our three
NTP server members.</p>

<p>Line 11 begins a files action.</p>

<p>Line 12 states that the following actions will be applied to hosts that do not
belong to the class “ntp_servers”. Presumably this will match all possible NTP
clients.</p>

<p>Line 13 identifies a target file of /etc/ntp.conf.</p>

<p>Lines 14-15 call the “AppendIfNoLine” bundle passing three strings that each
contain the word “server”, a space and the name of our three NTP servers.</p>

<p>Line 18 begins an “edit_line” bundle called “AppendIfNoline” The “a,b,c” part
defines three local variables that will take the arguments that were passed on
lines 14 and 15.</p>

<p>Lines 19-22 denote our strings, a location body part and its name: “append”.
This translates roughly to use the defined string at the current location in
the file for the “append” body part.</p>

<p>Line 25 define the location body part called “append”.</p>

<p>Line 26 tells Cfengine to insert our string after the current location which in
this case is the end of the file.</p>

<p>That did seem quite complicated for a seemingly simple action. It is a lot but
keep in mind that Cfengine is capable of far more complex edits. In such cases
this modular approach will help greatly.</p>

<h3>Disabling files</h3>

<p>This example shows how someone might disable an unwanted file. Disabling a file
simple involves renaming it and perhaps altering the permissions.</p>

<pre><code>1  bundle agent disableftp {
2      files:
3          &quot;/etc/vsftpd/vsftpd.conf&quot;
4              rename =&gt; disable;
5  }
6  
7  body rename disable{
8      disable =&gt; &quot;true&quot;;
9      disable_suffix =&gt; &quot;.cfdisabled&quot;;
10      disable_mode =&gt; &quot;0600&quot;;
11  }
</code></pre>

<p>Line 1 defines an agent bundle called “disableftp”.</p>

<p>Line 2 begins a files action.</p>

<p>Line 3 identifies our target file, an ftp daemon configuration file.</p>

<p>Line 4 calls a rename body part called “disable”.</p>

<p>Line 7 begins the body part called “disable”.</p>

<p>Line 8 tells Cfengine to disable the defined file. Other actions are possible
such as warn.</p>

<p>Line 9 defines the suffix to be added to the renamed file.</p>

<p>Line 10 defines the mode of the renamed file.</p>

<h3>Disabling processes</h3>

<p>Suppose you want to forbid a process from running on a particular server.</p>

<pre><code>1 processes:
2      secure_hosts::
3          &quot;stunnel&quot;   signals =&gt; { &quot;term&quot;, &quot;kill&quot; };
</code></pre>

<p>Line 1 identifies the processes action.</p>

<p>Line 2 identifies that the next action is for members of the “secure_hosts” class.</p>

<p>Line 3 tells the agent to check for a running process that matches the regular
expression “stunnel”. If any are found a “term” signal is sent that will
hopefully end the unwanted processes. If the “term” signal is unsuccessful then
a “kill” signal will be tried instead.</p>



            </article>
            <article>
                <header>
                    <h1><a href="/blog/2011/03/08/apt-cheatsheet/">Debian Apt Cheatsheet</a></h1>

                    <p class="tags">Tags:
                        <a href="/blog/tag/debian/" rel="tag">debian</a>
                        <a href="/blog/tag/apt/" rel="tag">apt</a>
                        <a href="/blog/tag/cheatsheet/" rel="tag">cheatsheet</a>
                    </p>

                    <aside>
                        <p><time datetime="2011-03-08">
                            Posted on 2011-03-08
                        </time>
                        </p>
                    </aside>

                </header>

                <p>Download and build source package   apt-get -b source <package name>
Download and install dependencies for source package  apt-get build-dep <package name>
Download source package    apt-get source <package name>
Install package “on demand”   auto-apt run <program>
List contents of a package    apt-file list <package name>
List installed packages    dpkg -l
Remove package and configuration files    apt-get --purge remove <package name>
Search for Debian Packages    http://www.debian.org/distrib/packages
Search for packages  apt-cache search <string>
Show package dependencies  apt-cache depends <string>
Show package information   apt-cache show <string>
Show package that supplies a given file   apt-file search <file name>
Show package that supplies a given file   COLUMNS=132 dpkg -S <file name>
Show source package information  apt-cache showsrc <package name>
Update apt-file and auto-apt database  apt-file update</package></file></file></string></string></string></package></package></program></package></package></package></p>



            </article>
            <article>
                <header>
                    <h1><a href="/blog/2011/03/07/heatbeat2-cheatsheet/">Heartbeat 2 cheatsheet</a></h1>

                    <p class="tags">Tags:
                        <a href="/blog/tag/cluster/" rel="tag">cluster</a>
                        <a href="/blog/tag/heartbeat/" rel="tag">heartbeat</a>
                        <a href="/blog/tag/cheatsheet/" rel="tag">cheatsheet</a>
                    </p>

                    <aside>
                        <p><time datetime="2011-03-07">
                            Posted on 2011-03-07
                        </time>
                        </p>
                    </aside>

                </header>

                <p>Commands
List cluster resources.    crm_resource -L
Dump cluster configuration as xml to stdout.    cibadmin -Q
Place node in standby (maintenance mode). Technically this is adding the standby property.   crm_standby -U <hostname> -v true
Place local node in standby.  crm_standby -v true
Place node online or remove the standby property.  crm_standby -D -U <hostname>
Place local node online or remove standby property.   crm_standby -D
View cluster status. One time to stdout.  crm_mon -1
View cluster status. Refresh every 3s.    crm_mon -i3
One line simple output.    crm_mon -s
Show inactive resources.   crm_mon -r
Stop resource.    crm_resource -r <resource> -p target_role -v stopped
Start resource.   crm_resource -r <resource> -p target_role -v started
Clear failed resource.  crm_resource -C -H <host> -r <resource>
Query running cluster for current state (STDOUT).  cibadmin -Q --obj_type resources
Other resources.  XML definition</resource></host></resource></resource></hostname></hostname></p>



            </article>
            <article>
                <header>
                    <h1><a href="/blog/2011/03/03/host-naming/">Choosing a host naming convention</a></h1>

                    <p class="tags">Tags:
                        <a href="/blog/tag/dns/" rel="tag">dns</a>
                    </p>

                    <aside>
                        <p><time datetime="2011-03-03">
                            Posted on 2011-03-03
                        </time>
                        </p>
                    </aside>

                </header>

                <p>Whether realizing it or not every organization goes through the process of selecting a naming convention. Often this is done without much forward planing resulting in unwieldy host and service names. In the worst cases host names are dropped completely and either by habit or lack of a proper DNS service only ip addresses are used.</p>

<p>In the following I will talk about the different types of naming conventions that I’ve experienced or read about. I’ll discuss the pros and cons of each. Before we get to that we’ll need to have a small refresher on domain name services.
DNS review</p>

<p>Domain name service is probably the most important and most overlooked of all network services. In many cases unexplained network problems can be attributed to improper or missing DNS. Some view DNS as complicated voodoo that is more trouble than it is worth.</p>

<p>The goal of DNS is very simple. ip addresses are difficult to remember. this is especially true of ipv6 ip addresses. DNS allows you assign easy to remember names to associate with an ip address. DNS allows further fine grained identification through specialized name and ip address matches.</p>

<pre><code>A record: this is the most basic record that associates a DNS name with an ip address.
PTR: Sometimes called a pointer or reverse record this associates an IP address with DNS name allowing a person or service to discover the DNS name of a known IP address. When building DNS records I often see these records missing and deemed unimportant. Without these a DNS service will not be complete and errors or service problems may occur.
MX RECORD: The MX record identifies the IP address and DNS name of mail servers (mail exchanger). Without these records mail will not flow.
NS RECORD: This identifies the IP address and DNS name of DNS servers. Without these records a DNS service cannot function.
CNAME: This record, sometimes called an alias, is optional but very useful and often overlooked. A CNAME allows for a host to have additional name records. As we’ll see being able to refer to a host via multiple names can be very useful.
</code></pre>

<p>DNS versus host name</p>

<p>It is important to differentiate between a DNS name and a host name. A DNS name is the name record of an IP address. A host name is the name that a host is assigned when it is setup, or changed to. The host name is known only to the host. DNS names and host names independent. They do not always match and there is no guarantee that they will. This is why a proper DNS service is so important. Without one there is no centralized way to refer to a host without knowing its IP address.
Naming conventions
Purpose</p>

<p>This style names host after there purpose.
Examples</p>

<p>Printer1, router1, www and exchange1.
Pros</p>

<p>These host names are easy to remember.
Cons</p>

<pre><code>As the number of alike services increases it can be difficult to remember if you are referring to printer1 or printer8.
Servers often have multiple purposes. Should a file and print server be called printer1, file1 or print-file1?
If a print server is to become a file server you’ll have to go through the trouble of renaming the server.
</code></pre>

<p>Geographic</p>

<p>This style attempts to chose names base on location such as city, office or even floor.
Example</p>

<p>Toronto1, kingst1, and 2ndfloor2.
Pros</p>

<p>You know where to find the server.
Cons</p>

<pre><code>What does the host do?
As the number of hosts at single location increase it can be difficult to remember if you are referring to toronto1 or toronto5.
Whenever a host is moved you’ll have to rename the server.
If you’re not using CNAMEs how will your customers refer to the host? Will you give them a new name if you move it?
This may give out more information about your host than you might wish.
</code></pre>

<p>Inventory</p>

<p>This style attempts to combine the purpose and geographic style in hopes of gaining an inventory system for all hosts. Some go even further to include the operating system in the host name.
Examples</p>

<p>tor-print01, 2ndflr-router02, kingst-exchange01, toronto-lnx-nfs1, kingst-csco-router1
Pros</p>

<p>This hostname tells you a lot about the host.
Cons</p>

<pre><code>Host names are long, difficult to remember and difficult to type. This is counter to the purpose of DNS.
What if a host has multiple purposes such as file and print?
You’ll have to rename a host each time it is re-purposed or moved.
While this might seem like a poor man’s inventory system it is no substitute for the real thing.
This may give out more information about your host than you might wish.
</code></pre>

<p>Themes</p>

<p>We’ve all seen hosts with whimsical names that seem to serve no purpose.
Examples</p>

<p>zeus, maple, blue, pluto
Pros</p>

<p>To the newcomer such host names seem meaningless. However, as they are short they are very easy to remember and type. People will quickly learn to associate such names with their purpose. This is a common technique for code names in industry and the military. These types of host names are the only ones that I can remember even long after I’ve stopped working with them. Further You can never run out of unique names.
Cons</p>

<pre><code>The host name tells nothing about the host. One might argue this as a pro since a cracker has no additional information.
What happens if a host is decommissioned? Are customers told to access a new host name?
</code></pre>

<p>CNAMEs</p>

<p>Using CNAMEs allows you to combine all of the above naming conventions in a single flexible system. Since a CNAME is an alias it can be reassigned to another host without either host requiring a host name change. This allows services to be moved without customers being aware of it. A customer can be pointed to a new web server simply by assigning the CNAME www to another host. The change is transparent.</p>

<p>Considering what you now know about CNAMEs. Go back and look at our naming styles again. We can now combine them in a much more useful way. A host simply called blue can have CNAMEs printer1, tor-printer or even blue-lnx-toronto-printer1. For administrators blue is easy to remember and type. Even if blue is decommissioned we simply reassign the CNAME to its replacement server. If the server is moved, installed with a new operating system or assigned a new purposed simple change the CNAME.
Examples</p>

<p>blue, blue-lnx-toronto-printer1, mars, mars-csc-kingst-brouter1
Pros</p>

<pre><code>Allows all of the benefits of the previously discussed conventions.
Allows for the movement of services and hosts without the need to change host names.
</code></pre>

<p>Cons</p>

<pre><code>Requires a functioning DNS service.
This may give out more information about your host than you might wish.
Current DNS implementations prevent clients from asking a DNS server to list the CNAMEs of a given A record. Instead the DNS server’s configuration must be examined in order to determine all CNAMEs.
Requires a little more work to keep CNAME records in addition to A and PTR records.
</code></pre>

<p>TXT and HINFO</p>

<p>There are two little known DNS records called TXT and HINFO. These are mostly free form records used to store arbitrary host information. Unlike CNAMEs one should be able to query these fields via a client. However, like some of our other methods this can sometimes offer too much information to a cracker. For more information about the TXT and HINFO refer to RFCs 1464 and 1033.</p>

<p>Whatever method you choose, and this list is by no means complete, be sure to plan ahead. Think about how your naming convention can adapt to a growing network as you add more nodes and move existing ones.</p>



            </article>
        </main>

        <ul class="pager">
            <li class="prev">
                <a class="button button-primary" href="/blog/page/8" rel="next">
                    ← Older
                </a>
            </li>
            <li class="next">
                <a class="button button-primary" href="/blog/page/6" rel="prev">
                    Newer →
                </a>
            </li>
        </ul>

    </div>

    <div class="three columns sidebar">
        
        <h1>Tags</h1>
        <ul class="list-inline">
            <li><a href="/blog/tag/apt/">apt</a></li>
            <li><a href="/blog/tag/backup/">backup</a></li>
            <li><a href="/blog/tag/cfengine/">cfengine</a></li>
            <li><a href="/blog/tag/cfengine-cookbook/">cfengine cookbook</a></li>
            <li><a href="/blog/tag/cheatsheet/">cheatsheet</a></li>
            <li><a href="/blog/tag/cli/">cli</a></li>
            <li><a href="/blog/tag/cluster/">cluster</a></li>
            <li><a href="/blog/tag/configuration-management/">configuration management</a></li>
            <li><a href="/blog/tag/cron/">cron</a></li>
            <li><a href="/blog/tag/debian/">debian</a></li>
            <li><a href="/blog/tag/dns/">dns</a></li>
            <li><a href="/blog/tag/dr/">dr</a></li>
            <li><a href="/blog/tag/heartbeat/">heartbeat</a></li>
            <li><a href="/blog/tag/high-availability/">high availability</a></li>
            <li><a href="/blog/tag/infosec/">infosec</a></li>
            <li><a href="/blog/tag/ipv6/">ipv6</a></li>
            <li><a href="/blog/tag/iscsi/">iscsi</a></li>
            <li><a href="/blog/tag/kvm/">kvm</a></li>
            <li><a href="/blog/tag/linux/">linux</a></li>
            <li><a href="/blog/tag/monitoring/">monitoring</a></li>
            <li><a href="/blog/tag/multipathd/">multipathd</a></li>
            <li><a href="/blog/tag/networking/">networking</a></li>
            <li><a href="/blog/tag/opensource/">opensource</a></li>
            <li><a href="/blog/tag/oracle/">oracle</a></li>
            <li><a href="/blog/tag/posix/">posix</a></li>
            <li><a href="/blog/tag/red-hat/">red hat</a></li>
            <li><a href="/blog/tag/regex/">regex</a></li>
            <li><a href="/blog/tag/rhev/">rhev</a></li>
            <li><a href="/blog/tag/san/">san</a></li>
            <li><a href="/blog/tag/shell/">shell</a></li>
            <li><a href="/blog/tag/solaris/">solaris</a></li>
            <li><a href="/blog/tag/ssh/">ssh</a></li>
            <li><a href="/blog/tag/subversion/">subversion</a></li>
            <li><a href="/blog/tag/sun/">sun</a></li>
            <li><a href="/blog/tag/support/">support</a></li>
            <li><a href="/blog/tag/svn/">svn</a></li>
            <li><a href="/blog/tag/sysadmin/">sysadmin</a></li>
            <li><a href="/blog/tag/vitualization/">vitualization</a></li>
        </ul>
        <h1>Feeds</h1>
        <ul class="list-inline">
            <li>
                <a href="/blog/index.atom" rel="alternate" type="application/atom+xml">
                    Atom
                </a>
            </li>
            <li>
                <a href="/blog/index.rss" rel="alternate" type="application/rss+xml">
                    RSS
                </a>
            </li>
        </ul>
    </div>

</div>


        </div>
        <footer>
            
            <div class="container tagline">
                <a href="http://preaction.github.io/Statocles">Made with Statocles</a><br>
                <a href="http://www.perl.org">Powered by Perl</a>
            </div>
        </footer>
    </body>
</html>
