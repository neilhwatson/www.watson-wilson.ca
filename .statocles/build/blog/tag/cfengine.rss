<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Neil H. Watson</title>
        <link>http://ettin/blog/tag/cfengine/</link>
        <atom:link href="http://ettin/blog/tag/cfengine.rss" rel="self" type="application/rss+xml" />
        <description>Blog feed of Neil H. Watson</description>
        <generator>Statocles 0.059</generator>
        <item>
            <title>Variable references with Cfengine</title>
            <link>http://ettin/blog/2012/10/19/cfengine-var-refs/</link>
            <guid>http://ettin/blog/2012/10/19/cfengine-var-refs/</guid>
            <description><![CDATA[
                <p>Variables in Cfengine can be confusing at times. Here are some examples of variable references. References are not strictly required, but they are good practice like using the strict module in Perl.</p>

<p>bundle agent main {</p>

<p>vars:
      &quot;meta_purpose&quot; string =&gt; &quot;Demonstrate references&quot;;</p>

<pre><code>  &quot;my_scalar&quot; string       =&gt; &quot;This is a scalar typed as astring&quot;;
  &quot;my_list&quot; slist          =&gt; { &quot;one&quot;, &quot;two&quot;, &quot;three&quot; };
  &quot;my_array[red]&quot; string   =&gt; &quot;Red element of associative array&quot;;
  &quot;my_array[blue]&quot; string  =&gt; &quot;Blue element of associative array&quot;;
  &quot;my_array[green]&quot; string =&gt; &quot;Green element of associative array&quot;;
</code></pre>

<p>methods:
      &quot;any&quot; usebundle =&gt; test(
         &quot;main.my_scalar&quot;,
         &quot;main.my_list&quot;,
         &quot;main.my_array&quot;
         );
}</p>

<p>bundle agent test(scalarref, listref, arrayref) {</p>

<p>vars:
      &quot;local_scalar&quot;
         string =&gt; &quot;${${scalarref}}&quot;;</p>

<pre><code>  &quot;local_list&quot;
     slist =&gt; { &quot;@{${listref}}&quot; };

  &quot;arrayref_index&quot;
     slist =&gt; getindices(&quot;${arrayref}&quot;);

  &quot;local_array[${arrayref_index}]&quot;
     string =&gt; &quot;${${arrayref}[${arrayref_index}]}&quot;;

  &quot;local_array_index&quot;
     policy =&gt; &#39;free&#39;,
     slist =&gt; getindices(&quot;local_array&quot;);
</code></pre>

<p>reports:
      cfengine::
         &quot;scalarref         =&gt; ${${scalarref}}&quot;;
         &quot;local_scalar      =&gt; ${local_scalar}&quot;;
         &quot;local_list        =&gt; ${local_list}&quot;;
         &quot;arrayref_index    =&gt; ${arrayref_index}&quot;;
         &quot;arrayref item     =&gt; ${${arrayref}[${arrayref_index}]}&quot;;
         &quot;local_array_index =&gt; ${local_array_index}&quot;;
         &quot;local_array item  =&gt; ${local_array[${local_array_index}]}&quot;;
}</p>

<p>Now let&#39;s run it:</p>

<p>$ cf-agent -f ./references.cf 
R: scalarref         =&gt; This is a scalar typed as astring
R: local_scalar      =&gt; This is a scalar typed as astring
R: local_list        =&gt; one
R: local_list        =&gt; two
R: local_list        =&gt; three
R: arrayref_index    =&gt; red
R: arrayref_index    =&gt; blue
R: arrayref_index    =&gt; green
R: arrayref item     =&gt; Red element of associative array
R: arrayref item     =&gt; Blue element of associative array
R: arrayref item     =&gt; Green element of associative array
R: local_array_index =&gt; green
R: local_array_index =&gt; red
R: local_array_index =&gt; blue
R: local_array item  =&gt; Green element of associative array
R: local_array item  =&gt; Red element of associative array
R: local_array item  =&gt; Blue element of associative array</p>

                    <p><a href="http://ettin/blog/2012/10/19/cfengine-var-refs/#section-2">Continue reading...</a></p>
                <p>Tags:
                    <a href="http://ettin/blog/tag/cfengine/">cfengine</a>
                </p>
            ]]></description>
            <pubDate>
                Fri, 19 Oct 2012 00:00:00 +0000
            </pubDate>
        </item>
        <item>
            <title>Backups using Cfengine</title>
            <link>http://ettin/blog/2011/10/02/cfengine-backups/</link>
            <guid>http://ettin/blog/2011/10/02/cfengine-backups/</guid>
            <description><![CDATA[
                <p>Problem</p>

<p>You want to use Cfengine for scheduling backups instead of crond.</p>

<p>Solution</p>

<p>Cfengine is flexible enough to allow for advanced time scheduling (see Cfengine as an atlernative to crond). Its file copying functions allow Cfengine to copy files directly as a backup program including advanced rsync behaviour. Cfengine shell commands allow you to use your own backup tools.</p>

<p>Earlier I discussed methods promises. I will make use of this again here.
The humble tar ball</p>

<p>First a method call.</p>

<p>bundle agent main {</p>

<p>vars:
      &quot;backupdir&quot; string =&gt; &quot;/srv/aux/backup&quot;,
         handle =&gt; &quot;main_vars_backupdir&quot;,
         comment =&gt; &quot;Location for backups&quot;;</p>

<pre><code>  &quot;backups&quot; slist =&gt; {
        &quot;/home/neil/.kde/share/apps/amarok&quot;,
        &quot;/home/neil/.ssh&quot;,
        &quot;/home/neil/.gnupg&quot;,
        &quot;/home/neil/.gnucash&quot;,
        &quot;/home/neil/Mail&quot;,
        &quot;/srv/music/playlists&quot;,
        &quot;/etc&quot;,
        &quot;/var/www&quot;,
        &quot;/srv/svn/&quot;
     },
     handle =&gt; &quot;vars_home_backups&quot;,
     comment =&gt; &quot;Dirs to backup&quot;;
</code></pre>

<p>methods:</p>

<pre><code>  Hr01::

     &quot;backup&quot; usebundle =&gt; backup( 
           ${backupdir}, 
           @{main.backups} ),
        action =&gt; if_elapsed(&quot;60&quot;),
        depends_on =&gt; { &quot;svn_checkin&quot; },
        handle =&gt; &quot;main_methods_home_backups&quot;;
</code></pre>

<p>}</p>

<p>Here we set some variables for a backup directory and a list of things to backup. Doing this allows us to change the variables by class from host to host. Next we call the bundle via a method passing the variables. Note that list variables must be fully scoped by listing their bundle name.</p>

<p>The bundle is called at 0100 hours. If_elapsed ensures that the backup in only promised once during that hour. Depends_on shows what other bundles might need to be done first. In this case I need a Subversion promise ahead of time.</p>

<p>The magic here is that not only will the bundle go off at 0100 but like all Cfengine promises it will continually try, for every run during that hour, to ensure that that promise is kept. Now let’s look at the called bundle.</p>

<p>bundle agent backup(dir, backups) {</p>

<p>vars:</p>

<p>&quot;dirs&quot; string =&gt; join(&quot; &quot;, &quot;backups&quot;),
      handle =&gt; &quot;backup_vars_dirs&quot;,
      comment =&gt; &quot;Make list of string for tar&quot;;</p>

<p>files:</p>

<p>&quot;${dir}/.&quot;
      handle =&gt; &quot;backup_files_srv_backups&quot;,
      create =&gt; &quot;true&quot;;</p>

<p>commands:</p>

<p>&quot;/bin/tar -czf ${dir}/cfbackup-${g.day}.tgz ${dirs}&quot;
      handle =&gt; &quot;backup_commands_tar&quot;,
      contain =&gt; silent,
      classes =&gt; if_else(&quot;backup_go_encrypt&quot;,&quot;backup_tar_failed&quot;);</p>

<p>reports:</p>

<p>backup_tar_failed::
      &quot;Backup tar command failed.&quot;; 
}</p>

<p>The bundle is quite simple. A tar command is run using the passed variables as a target for the tar file and a list of things to tar up. The variable ‘g.day’ is a global variable that always contains a three letter abbreviation of today (e.g. sun, mon, tue). This is not built in. I set this in a common bundle. The files promise ensure that the location for the tar file is always there. The reports promise reports if the tar command throws and error. This would not be necessary in Nova since it keeps track of promise compliance automatically.</p>

<p>A peek inside this backup directory shows:</p>

<h1>ls /srv/aux/backup/cfbackup*</h1>

<p>/srv/aux/backup/cfbackup-fri.tgz
/srv/aux/backup/cfbackup-sun.tgz
/srv/aux/backup/cfbackup-wed.tgz
/srv/aux/backup/cfbackup-mon.tgz
/srv/aux/backup/cfbackup-thu.tgz
/srv/aux/backup/cfbackup-sat.tgz
/srv/aux/backup/cfbackup-tue.tgz</p>

<p>A simple copy</p>

<p>I have a directory of images from my camera work. I like to back this up to another hard drive on my workstation. First the method.</p>

<p>methods:</p>

<p>Hr01::</p>

<pre><code>  &quot;backup_pictures&quot; usebundle =&gt; local_sync(
        &quot;/home/neil/Pictures&quot;,
        &quot;/srv/aux/backup-pictures&quot;
     ),
     action =&gt; if_elapsed(&quot;10080&quot;),
     handle =&gt; &quot;main_methods_local_sync_pictures&quot;;
</code></pre>

<p>This method passes two strings, both directories, to a bundle. The if_elapsed body sets the frequency of this backup to once per week. Now the bundle.</p>

<p>bundle agent local_sync(src, dest){</p>

<p>files:</p>

<p>&quot;${dest}/.&quot;
      handle =&gt; &quot;local_sync_files_dest_create&quot;,
      create =&gt; &quot;true&quot;,
      perms =&gt; mog(&quot;644&quot;,&quot;root&quot;,&quot;root&quot;);</p>

<p>&quot;${dest}&quot;
      handle =&gt; &quot;local_sync_files_dest_copy&quot;,
      depth_search =&gt; recurse(&quot;inf&quot;),
      copy_from =&gt; local_cp(&quot;${src}&quot;);
}</p>

<p>Two files promises are found here. The first ensure that the destination directory is available. The second copies files from the source, provided by the method above to the destination, also provided by the method. The copy_from body is found in the standard Cfengine library. This is just a straight copy. I could have used a purge in the copy_from body to perform a sync function instead.
Encryption and off-site backups</p>

<p>Some of my backups are sent to an off-site host. I don&#39;t fully trust the off-site location so I encrypt the backup files first. Again from my main bundle.</p>

<p>methods:</p>

<p>&quot;backup_encrypt_neil&quot; usebundle =&gt; backup_encrypt_neil(&quot;cfbackup-${g.day}.tgz&quot;),
      action =&gt; if_elapsed(&quot;60&quot;),
      handle =&gt; &quot;main_methods__backup_encrypt_neil_cfbackup&quot;;</p>

<p>oort.(Saturday|Wednesday).(Hr10|Hr11)::</p>

<pre><code>  &quot;remote_backup&quot; usebundle =&gt; remote_backup_vps,
     handle =&gt; &quot;main_methods_oort_remote_backup_vps&quot;,
     comment =&gt; &quot;CEST time zone&quot;,
     action =&gt; if_elapsed(&quot;120&quot;);
</code></pre>

<p>The first method calls a bundle make encrypted copies of my backup tar balls. The second method is invoked on a remote host called ‘oort’. It is invoked on Saturday or Wednesday during the hours of 1000 or 1100 local time. The if_elapsed sets the span of two hours to ensure the promise is kept. Now the bundles.</p>

<p>bundle agent backup_encrypt_neil(file) {</p>

<p>vars:</p>

<p>&quot;backup_dir&quot; string =&gt; &quot;/srv/aux/backup&quot;,
      handle =&gt; &quot;backup_encrype_neil_backup_dir&quot;;</p>

<p>&quot;encrypted_dir&quot; string =&gt; &quot;/srv/aux/backup/encrypted&quot;,
      handle =&gt; &quot;backup_encrype_neil_encrypted_dir&quot;;</p>

<p>files:</p>

<p>&quot;${encrypted_dir}/.&quot;
      handle =&gt; &quot;backup_encrypt_neil_files_encrypted&quot;,
      create =&gt; &quot;true&quot;;</p>

<p>commands:</p>

<p>&quot;/usr/bin/gpg -r &#39;Neil Watson&#39; -o  ${encrypted_dir}/${file}.en -e ${backup_dir}/${file}&quot;,
      contain =&gt; silent,
      handle =&gt; &quot;backup_encrypt_neil_commands_encrypt&quot;;
}</p>

<p>This bundle calls GNUpg via a commands promise to encrypt the given tar file. A files promise ensures that the directory for the encrypted file to reside exists.</p>

<p>A peek inside the encrypted directory shows:</p>

<h1>ls /srv/aux/backup/encrypted/cfbackup*</h1>

<p>/srv/aux/backup/encrypted/cfbackup-fri.tgz.en
/srv/aux/backup/encrypted/cfbackup-thu.tgz.en
/srv/aux/backup/encrypted/cfbackup-mon.tgz.en
/srv/aux/backup/encrypted/cfbackup-tue.tgz.en
/srv/aux/backup/encrypted/cfbackup-sat.tgz.en
/srv/aux/backup/encrypted/cfbackup-wed.tgz.en
/srv/aux/backup/encrypted/cfbackup-sun.tgz.en</p>

<p>Now the remote backup bundle.</p>

<p>bundle agent remote_backup_vps {</p>

<p>files:</p>

<p>&quot;/home/neil/backups&quot;
      handle =&gt; &quot;remote_backup_vps_files_backups&quot;,
      depth_search =&gt; recurse(&quot;inf&quot;),
      file_select =&gt; by_name(&quot;.<em>?${g.day}.</em>?.en&quot;),
      copy_from =&gt; remote_dcp(
         &quot;/srv/aux/backup/encrypted&quot;,
         &quot;${sys.policy_hub}&quot;
      );
}</p>

<p>This last bundle is another files promise that performs a copy. The file_select body ensure that only the tar file that matches today’s tar file is copied. The thing to remember with this type of operation is that the server listed in the copy_from body is whatever host houses the backups. In this case it is my policy hub. However it could be any host running Cfengine so long as the proper access rules are applied.</p>

<p>Should you be using Nova you can use something called remote classes. Remote classes are classes that are set on one client so that other clients can query it. In this example I could have the host that encrypts the files set a class called ‘encrypted_files_ready’. The remote host could query for this class. If it is set then kickoff of the remote backup bundle.</p>

                    <p><a href="http://ettin/blog/2011/10/02/cfengine-backups/#section-2">Continue reading...</a></p>
                <p>Tags:
                    <a href="http://ettin/blog/tag/cfengine/">cfengine</a>
                    <a href="http://ettin/blog/tag/cfengine-cookbook/">cfengine cookbook</a>
                    <a href="http://ettin/blog/tag/backup/">backup</a>
                    <a href="http://ettin/blog/tag/dr/">dr</a>
                </p>
            ]]></description>
            <pubDate>
                Sun, 02 Oct 2011 00:00:00 +0000
            </pubDate>
        </item>
        <item>
            <title>CFEngine as a crond alternative</title>
            <link>http://ettin/blog/2011/09/27/cfengine-alt-crond/</link>
            <guid>http://ettin/blog/2011/09/27/cfengine-alt-crond/</guid>
            <description><![CDATA[
                <p>Cfengine’s time based classes and promise theory make it an attractive alternative to venerable crond.</p>

<p>It helps if the reader is familiar with Cfengine syntax. If not, then skip the syntax and just be aware that what is described is possible.</p>

<p>Both crond and Cfengine have flexible time descriptions but, Cfengine offers more.
Cfengine versus Crond Time criteria    Crond    Cfengine
Clock hour  0, 1, 2 ... 23    Hr00, Hr01, Hr03 ... Hr23
Clock minutes  0, 1, 2, .. 59    Min00, Min01, Min02 ... Min59
Day of week    0, 1, 2 ... 7  Sunday, Monday ... Friday
Month    1, 2, 3 .. 12  January, February ... December
Day of month   1, 2, 3 .. 31  Day1, Day2 ... Day31
Year  n/a   Yr1997, Yr2009
Six hour shift    0,1,2,3,4,5    Night, Morning, Afternoon, Evening</p>

<p>Let’s look at some time criteria and how both crond and Cfengine can be used to describe them.</p>

<pre><code>May 9 at 0900.
    In cron

    0 9 9 6 *

    In Cfengine

    May.Day9.Hr09.Min00::

Sundays at 0700.
    In Cron

    0 7 * * 0

    In Cfengine

    Sunday.Hr07.Min00::

Last Saturday of the month.
    In Cron: Possible with an external shell script.
    In Cfengine: Complicated but possible.

    January|March|May|July|August|October|December::
    &quot;Last_Saturday&quot; and =&gt; { &quot;Saturday&quot;, classmatch(&quot;Day(2[5-9]|3[01])&quot;) };

    April|June|September|November::
    &quot;Last_Saturday&quot; and =&gt; { &quot;Saturday&quot;, classmatch(&quot;Day(2[4-9]|30)&quot;) };

    February::
    &quot;Last_Saturday&quot; and =&gt; { &quot;Saturday&quot;, classmatch(&quot;Day2[2-9]&quot;) };
</code></pre>

<p>You can also use Cfengine to account for organizational holidays. This allows for jobs to be skipped on those days. For example.</p>

<p>classes:
   &quot;Holidays&quot; or =&gt; { &quot;January.Day1&quot;, &quot;December.Day25&quot; };</p>

<p>commands:</p>

<p>Hr07.Min00.!Holidays::
      &quot;/usr/bin/tar .... etc&quot;;</p>

<p>Reliability.</p>

<p>This is where Cfengine can outshine crond. If crond misses its time window or if the command fails crond will not retry until the time window returns. Using Cfengine, if the command fails Cfengine will not consider the promise kept. It will try again during the next run. Cfengine runs as frequently as five minute intervals. Consider this typical backup cron job.</p>

<p>0 5 * * * * tar -czf /root/backup.tgz /home /etc /data</p>

<p>We know that the crond job will run at exactly 0500 hours. If something goes wrong nothing will happen for another 24 hours. Now consider a Cfengine backup job.</p>

<p>Hr05::
   &quot;/usr/bin/tar -czf /root/backup.tgz /home /etc /data&quot;
      ifelapsed =&gt; if_elapsed(&quot;60&quot;);</p>

<p>The Cfengine job will attempt to execute the tar command during each of its runs during the hour 0500. If the command fails Cfengine will try again during its next run as long as it is during the 0500 hour. If the command succeeds then Cfengine will not attempt to run the tar command again for another 60 minutes. Thus Cfengine promises to successfully execute the command once during the hour 0500.
Dependencies</p>

<p>Enterprise schedulers can run jobs based on the outcome of other jobs. This works even between hosts. Try doing this with crond without custom work. Cfengine does have this ability. Cfengine Nova, the commercial edition, has something called remote classes. Without going into detail, remote classes allow a host to determine the status of a job on another host. Cfengine can use this status to set conditions and run jobs as desired.
Conclusions</p>

<p>Most shops stick to standard cron jobs. A few make the leap to enterprise schedulers. Cfengine offers a middle ground in terms of cost and offers the usual features that it is renowned for, host configuration management.</p>

                    <p><a href="http://ettin/blog/2011/09/27/cfengine-alt-crond/#section-2">Continue reading...</a></p>
                <p>Tags:
                    <a href="http://ettin/blog/tag/cfengine/">cfengine</a>
                    <a href="http://ettin/blog/tag/configuration-management/">configuration management</a>
                    <a href="http://ettin/blog/tag/cron/">cron</a>
                </p>
            ]]></description>
            <pubDate>
                Tue, 27 Sep 2011 00:00:00 +0000
            </pubDate>
        </item>
        <item>
            <title>Dynamic bundlesequence in Cfengine</title>
            <link>http://ettin/blog/2011/09/16/cfengine-dynamic-bundlesequence/</link>
            <guid>http://ettin/blog/2011/09/16/cfengine-dynamic-bundlesequence/</guid>
            <description><![CDATA[
                <p>Problem</p>

<p>You want to have your bundlesequence change based on class.</p>

<p>Solution</p>

<p>This question comes up regularly on the Cfengine mailing list. The secret is to build a string list based on class. The alternative is to use methods.</p>

<p>bundle common g {
    vars:</p>

<pre><code>    any::

        &quot;bseq&quot; slist =&gt; {
            &quot;site&quot;,
            &quot;ntp&quot;,
            &quot;hard&quot;
        },
        policy =&gt; &quot;free&quot;;

    cf_dbs::

        &quot;bseq&quot; slist =&gt; {
            @{bseq},
            &quot;db2&quot;,
            &quot;mysql&quot;
        },
        policy =&gt; &quot;free&quot;;

    cf_webfarm::

        &quot;bseq&quot; slist =&gt; {
            @{bseq},
            &quot;httpd&quot;,
            &quot;proxy&quot;
        },
        policy =&gt; &quot;free&quot;;
</code></pre>

<p>}</p>

<p>body common control {</p>

<pre><code>bundlesequence =&gt; { &quot;@{g.bseq}&quot; };
</code></pre>

<p>}</p>

<p>bundle agent site{
    reports:
        cfengine_3::
            &quot;site bundle&quot;;
}
bundle agent ntp{
    reports:
        cfengine_3::
            &quot;ntp bundle&quot;;
}
bundle agent hard{
    reports:
        cfengine_3::
            &quot;hard bundle&quot;;
}
bundle agent db2{
    reports:
        cfengine_3::
            &quot;db2 bundle&quot;;
}
bundle agent mysql{
    reports:
        cfengine_3::
            &quot;mysql bundle&quot;;
}
bundle agent httpd{
        reports:
            cfengine_3::
                &quot;httpd bundle&quot;;
}
bundle agent proxy{
        reports:
            cfengine_3::
                &quot;proxy bundle&quot;;
}</p>

<p>Although left out here for brevity, under normal conditions you would have a classes section in the common g bundle to define what hosts belong to the classes cf_dbs and cf_webfarm. In the vars section you can see how we build upon the default bseq list first defined for the any class. The policy body part allows us to redefine the variable. By default Cfengine does not allow variable values to be changed.</p>

<p>Please note that due to normal ordering vars promises are evaluated before classes promises. So the custom classes cf_dbs and cf_webfarm must be declared in a common bundle above the common g bundle. For example:</p>

<p>bundle common classes {
   classes:</p>

<pre><code>  &quot;cf_dbs&quot; or =&gt; { &quot;hosta&quot;, &quot;hostb&quot;, &quot;hostc&quot; };
</code></pre>

<p>}
bundle common g {
    vars:</p>

<pre><code>    any::

        &quot;bseq&quot; slist =&gt; {
            &quot;site&quot;,
            &quot;ntp&quot;,
            &quot;hard&quot;
        },
        policy =&gt; &quot;free&quot;;

    cf_dbs::

        &quot;bseq&quot; slist =&gt; {
            @{bseq},
            &quot;db2&quot;,
            &quot;mysql&quot;
        },
        policy =&gt; &quot;free&quot;;
</code></pre>

<p>..</p>

<p>For this exercise we can set the classes manually using the -D command switch. Below you can see how the bundle sequence changes for each class starting with the default any class.</p>

<p>neil@ettin ~/.cfagent/inputs $ cf-agent -f ./recipe.cf
R: site bundle
R: ntp bundle
R: hard bundle
neil@ettin ~/.cfagent/inputs $ cf-agent -KD cf_dbs -f ./recipe.cf
R: site bundle
R: ntp bundle
R: hard bundle
R: db2 bundle
R: mysql bundle
neil@ettin ~/.cfagent/inputs $ cf-agent -KD cf_webfarm -f ./recipe.cf
R: site bundle
R: ntp bundle
R: hard bundle
R: httpd bundle
R: proxy bundle</p>

<p>People do this with inputs too. If your inputs holds secret information like passwords this can be useful.</p>

<p>An alternative method to a dynamic bundle sequence is to use methods.</p>

<p>body common control {</p>

<pre><code>bundlesequence =&gt; { &quot;main&quot; };
</code></pre>

<p>}</p>

<p>bundle agent main{</p>

<pre><code>methods:

    any::

        &quot;any&quot; usebundle =&gt; site;
        &quot;any&quot; usebundle =&gt; ntp;
        &quot;any&quot; usebundle =&gt; hard;

    cf_dbs::

        &quot;cf_dbs&quot; usebundle =&gt; db2;
        &quot;cf_dbs&quot; usebundle =&gt; mysql;

    cf_webfarm::

        &quot;cf_dbs&quot; usebundle =&gt; httpd;
        &quot;cf_dbs&quot; usebundle =&gt; proxy;
</code></pre>

<p>}</p>

<p>bundle agent site{
    reports:
        cfengine_3::
            &quot;site bundle&quot;;
}
bundle agent ntp{
    reports:
        cfengine_3::
            &quot;ntp bundle&quot;;
}
bundle agent hard{
    reports:
        cfengine_3::
            &quot;hard bundle&quot;;
}
bundle agent db2{
    reports:
        cfengine_3::
            &quot;db2 bundle&quot;;
}
bundle agent mysql{
    reports:
        cfengine_3::
            &quot;mysql bundle&quot;;
}
bundle agent httpd{
        reports:
            cfengine_3::
                &quot;httpd bundle&quot;;
}
bundle agent proxy{
        reports:
            cfengine_3::
                &quot;proxy bundle&quot;;
}</p>

<p>The result is exactly the same. However using methods allows you to pass parameters to the bundles. Also you can define your classes for cf_dbs and cf_webfarms in the same main bundle. For example:</p>

<p>body common control {</p>

<pre><code>bundlesequence =&gt; { &quot;main&quot; };
</code></pre>

<p>}
bundle agent main{</p>

<pre><code>vars:

    cf_dbs1::

        &quot;db2_version&quot; string =&gt; &quot;9.1&quot;;

    cf_dbs2::

        &quot;db2_version&quot; string =&gt; &quot;9.2&quot;;

classes:

    &quot;cf_dbs1&quot; or =&gt; { &quot;dbhost1&quot;, &quot;dbhost2&quot;, &quot;dbhost3&quot; };
    &quot;cf_dbs2&quot; or =&gt; { &quot;dbhost4&quot;, &quot;dbhost5&quot;, &quot;dbhost6&quot; };
    &quot;cf_dbs&quot; or =&gt; { &quot;cf_dbs1&quot;, &quot;cf_dbs2&quot; };

methods:

    any::

        &quot;any&quot; usebundle =&gt; site;
        &quot;any&quot; usebundle =&gt; ntp;
        &quot;any&quot; usebundle =&gt; hard;

    cf_dbs::

        &quot;cf_dbs&quot; usebundle =&gt; db2( &quot;${db2_version}&quot; );
        &quot;cf_dbs&quot; usebundle =&gt; mysql;
</code></pre>

<p>}</p>

<p>bundle agent site{
    reports:
        cfengine_3::
            &quot;site bundle&quot;;
}
bundle agent ntp{
    reports:
        cfengine_3::
            &quot;ntp bundle&quot;;
}
bundle agent hard{
    reports:
        cfengine_3::
            &quot;hard bundle&quot;;
}
bundle agent db2(version){
    reports:
        cfengine_3::
            &quot;db2 bundle ${version}&quot;;
}
bundle agent mysql{
    reports:
        cfengine_3::
            &quot;mysql bundle&quot;;
}</p>

<p>Here we define groups of database host classes. Hosts with the hostname dbhost1 to dbhost3 are members of the cf_dbs1 class. Members of that class have the db2_version string set to 9.1. Using classes we not only determine which bundles are run but what parameters can be passed to them.</p>

<p>neil@ettin ~/.cfagent/inputs $ cf-agent -Kf ./recipe.cf
R: site bundle
R: ntp bundle
R: hard bundle
neil@ettin ~/.cfagent/inputs $ cf-agent -D dbhost1 -Kf ./recipe.cf
R: site bundle
R: ntp bundle
R: hard bundle
R: db2 bundle 9.1
R: mysql bundle
neil@ettin ~/.cfagent/inputs $ cf-agent -D dbhost4 -Kf ./recipe.cf
R: site bundle
R: ntp bundle
R: hard bundle
R: db2 bundle 9.2
R: mysql bundle</p>

                    <p><a href="http://ettin/blog/2011/09/16/cfengine-dynamic-bundlesequence/#section-2">Continue reading...</a></p>
                <p>Tags:
                    <a href="http://ettin/blog/tag/cfengine/">cfengine</a>
                    <a href="http://ettin/blog/tag/cfengine-cookbook/">cfengine cookbook</a>
                    <a href="http://ettin/blog/tag/configuration-management/">configuration management</a>
                </p>
            ]]></description>
            <pubDate>
                Fri, 16 Sep 2011 00:00:00 +0000
            </pubDate>
        </item>
        <item>
            <title>Template files using Cfengine</title>
            <link>http://ettin/blog/2011/05/26/cfengine-templates/</link>
            <guid>http://ettin/blog/2011/05/26/cfengine-templates/</guid>
            <description><![CDATA[
                <p>Problem</p>

<p>Sometimes a file’s contents depends upon the class of host that the file resides on. This makes file copy promises impractical. Who wants to copy a different file for so many hosts? Sysadmins are a lazy lot.</p>

<p>Solution</p>

<p>Template files consist of two promises. One promise copies a base file whilst the second promise edits the base file. The key is the contents of the base file. It contains the names of Cfengine variables. These variables are expanded during the edit.</p>

<p>bundle agent recipe {</p>

<p>vars:
    mars::
      &quot;manager&quot; string =&gt; &quot;Neil Watson&quot;;
      &quot;phone&quot; string =&gt; &quot;555-555-5555&quot;;
      &quot;email&quot; string =&gt; &quot;neil@example.com&quot;;</p>

<pre><code>venus::
  &quot;manager&quot; string =&gt; &quot;Lisamarie Wilson&quot;;
  &quot;phone&quot; string =&gt; &quot;555-555-5554&quot;;
  &quot;email&quot; string =&gt; &quot;lisa@example.com&quot;;
</code></pre>

<p>files:
    &quot;/tmp/motd.tmp&quot;
      handle =&gt; &quot;motd_template&quot;,
      comment =&gt; &quot;MOTD template file&quot;,
      perms =&gt; mog(&quot;0644&quot;,&quot;root&quot;,&quot;root&quot;),
      copy_from =&gt; remote_cp (&quot;/var/cf-masterfiles/motd.tmp&quot;,&quot;localhost&quot;);</p>

<pre><code>&quot;/etc/motd&quot;
  handle =&gt; &quot;motd_file&quot;,
  comment =&gt; &quot;Expand motd file from template&quot;,
  create =&gt; &quot;true&quot;,
  edit_line =&gt; expand_template(&quot;/tmp/motd.tmp&quot;);
</code></pre>

<p>}</p>

<p>Here is our template file motd.tmp</p>

<h6>#</h6>

<p>This host is the property of Example.com.  Use is restricted to
authorized personnel only.</p>

<p>Manager:        ${recipe.manager}
Phone:          ${recipe.phone}
Email:          ${recipe.email}</p>

<h6>#</h6>

<p>Here is the verbose output from the agent.</p>

<p>cf3  !! Image file /tmp/motd.tmp out of date (should be copy of
/vars:/cf-masterfiles/motd.tmp)
cf3  -&gt; Updated /tmp/motd.tmp from source /vars:/cf-masterfiles/motd.tmp
on localhost
cf3  -&gt; Copy of regular file succeeded /vars:/cf-masterfiles/motd.tmp to
/tmp/motd.tmp.cfnew
cf3  -&gt; Not attempting to preserve file permissions from the source
cf3  -&gt; Object /tmp/motd.tmp had permission 600, changed it to 644
...
cf3  -&gt; Using literal pathtype for /etc/motd
cf3  -&gt; File &quot;/etc/motd&quot; exists as promised
cf3  -&gt; Handling file existence constraints on /etc/motd
cf3  -&gt; Handling file edits in edit_line bundle expand_template
cf3 
cf3       * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* *
cf3       BUNDLE expand_template( {&#39;/tmp/motd.tmp&#39;} )
cf3       * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* *
cf3 
cf3     ? Augment scope expand_template with templatefile
cf3      ??  Private class context
cf3 
cf3 
cf3       = = = = = = = = = = = = = = = = = = = = = = = = = = = =&gt;
cf3       insert_lines in bundle expand_template
cf3       = = = = = = = = = = = = = = = = = = = = = = = = = = = =&gt;
cf3 
cf3 
cf3     .........................................................
cf3     Promise handle: 
cf3     Promise made by: /tmp/motd.tmp
cf3 
cf3     Comment:  Expand variables in the template file
cf3     .........................................................
cf3 
cf3  -&gt; Promised file line &quot;###################################&quot; exists
within file /etc/motd (
cf3  -&gt; Promised file line &quot;This host is the property of
Example.com.  Use is restricted to aut
motd (promise kept)
cf3  -&gt; Promised file line &quot;&quot; exists within file /etc/motd (promise
kept)
cf3  -&gt; Inserting the promised line &quot;Manager:   Lisamarie Wilson&quot; into
/etc/motd after locator
cf3  -&gt; Inserting the promised line &quot;Phone:             555-555-5554&quot;
into /etc/motd after loca
cf3  -&gt; Inserting the promised line &quot;Email:
lisa@example.com&quot; into /etc/motd after 
cf3  -&gt; Promised file line &quot;###################################&quot; exists
within file /etc/motd (
cf3      ??  Private class context</p>

<p>The output is slightly truncated to fit this page but its meaning is clear enough. First the agent copies motd.tmp to /tmp and then edits /etc/motd using /tmp/motd.tmp as a template and expanding the variables set in the bundle recipe. Note that the variables listed in the template file are specifically scoped to the bundle recipe. The resulting file is below.</p>

<h6>#</h6>

<p>This host is the property of Example.com.  Use is restricted to
authorized personal only.</p>

<p>Manager:        Lisamarie Wilson
Phone:          555-555-5554
Email:          lisa@example.com</p>

<h6>#</h6>

<p>Note that Cfengine edits are very efficient. Cfengine performs the edit in memory first and compares the result with the target file. These edits are only committed to the target file if there are actual changes thus sparing needless writes.</p>

                    <p><a href="http://ettin/blog/2011/05/26/cfengine-templates/#section-2">Continue reading...</a></p>
                <p>Tags:
                    <a href="http://ettin/blog/tag/cfengine/">cfengine</a>
                    <a href="http://ettin/blog/tag/cfengine-cookbook/">cfengine cookbook</a>
                    <a href="http://ettin/blog/tag/configuration-management/">configuration management</a>
                </p>
            ]]></description>
            <pubDate>
                Thu, 26 May 2011 00:00:00 +0000
            </pubDate>
        </item>
    </channel>
</rss>

